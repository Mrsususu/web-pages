
<!-- ********************************************************************************* -->

<!-- 时间设置，Date()的使用，setInterval()的使用 -->
<!--
<!DOCTYPE HTML>
  <html>
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>计时器</title>
  <script type="text/javascript">
  var attime
     function clock(){
        var time=new Date();  
        attime=time.getHours()+":"+time.getMinutes()+":"+time.getSeconds();
        document.getElementById("clock").value = attime;
     }
      var i=setInterval(clock,100);
      function stop(){
        clearInterval(i)
      }
  </script>
  </head>
  <body>
    <form>
      <input type="text" id="clock" size="50"  />
      <input type="button" value="Stop" onclick="stop()" />
      </form>
  </body>
  </html>
-->

<!-- ********************************************************************************* -->

<!-- setTimeout()计时器，在载入后延迟指定时间后,去执行一次表达式,仅执行一次/claerTimeout() -->
<!--
<!DOCTYPE HTML>
<html>
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>计时器</title>
  </head>

  </head>
  <body>
    <form>
    <input type="text" id="count" />
    </form>

    <script type="text/javascript">
      var num=0;
      function startCount() {
        document.getElementById('count').value=num;
        num=num+1;
        setTimeout("startCount()",1000); 
      }
      startCount();
    </script>
  </body>
</html>

<!DOCTYPE HTML>
<html>
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>计时器</title>
  </head>
    <script type="text/javascript">
      var num=0;
      function startCount() {
        document.getElementById('count').value=num;
        num=num+1;
        setTimeout("startCount()",1000); //其和setTimeout(startCount(),1000); 等价
      }
      setTimeout("startCount()",1000);  //注意和前面的区别，如果此句为startCount();，则js整体代码必须放在body的最后。即在DOM树建立之后才能执行，不然会报错。
    </script>
  </head>
  <body>
    <form>
    <input type="text" id="count" />
    </form>
  </body>
</html>
-->

<!-- ********************************************************************************* -->

<!-- window.history 记录浏览器曾经浏览过的页面 -->
<!-- window.history.back()/window.history.forward()/window.history.go(),go()中0为当前页面，-1为back()，1为forward() -->
<!--
<!DOCTYPE HTML>
<html>
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>History对象</title>
  </head>
  <script type="text/javascript">
    var HL = window.history.length   ;
    document.write(HL);
  </script>
  <body>
  </body>
</html>
-->

<!-- ********************************************************************************* -->

<!-- window.location 当前的href。window.location.href 也是显示当前的href，同时可以通过这个句子对当前href进行修改操作。 -->
<!-- 注意a中的href可以添加javascript代码 -->
<!--
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>计时返回页面</title>
</head>
<body>
  <h4>操作成功</h4>
  <p>
    <b id="second">5</b>秒后返回到主页<a href="javascript:goBack();">返回</a>
  </p>
  <script type="text/javascript">
    var sec = document.getElementById('second');
    var i = sec.textContent;
    var time = setInterval(function(){
      i --;
      sec.innerHTML = i;
      if(i == 0){
        clearInterval(time);
        window.location.href =  "http://www.imooc.com/";
      }
    },1000);

    function goBack(){
      window.history.back();
    }
  </script>
</body>
</html>
-->

<!-- ********************************************************************************* -->

<!-- Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 -->

<!-- ********************************************************************************* -->

<!--
  屏幕实际宽高：screen.width/screen.height
  窗口可以使用的屏幕宽高，即减去页面特性，如底部任务栏：screen.availWidth/screen.availHeight
-->

<!-- ********************************************************************************* -->

<!--
  获取元素还有getElementsByName()，多用在input中，因为input有name属性
  取input框内输入的值，为.value
-->

<!-- 下面例子主要看checked属性的使用，即还没有存在的时候就可以直接用checked，而不需要再setAttribute。另，注意parseInt(j)的使用，在用value获取input框内值之后，一般都需要用这个参数。 -->
<!--
<!DOCTYPE HTML>
<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="Content-Type" content="text/html; charset=gb2312">
        <title>无标题文档</title>
    </head>
    
    <body>
        <form>
          请选择你爱好:<br>
          <input type="checkbox" name="hobby" id="hobby1">  音乐
          <input type="checkbox" name="hobby" id="hobby2">  登山
          <input type="checkbox" name="hobby" id="hobby3">  游泳
          <input type="checkbox" name="hobby" id="hobby4">  阅读
          <input type="checkbox" name="hobby" id="hobby5">  打球
          <input type="checkbox" name="hobby" id="hobby6">  跑步 <br>
          <input type="button" value = "全选" onclick = "checkall();">
          <input type="button" value = "全不选" onclick = "clearall();">
          <p>请输入您要选择爱好的序号，序号为1-6:</p>
          <input id="wb" name="wb" type="text" >
          <input name="ok" type="button" value="确定" onclick = "checkone();">
        </form>
        <script type="text/javascript">
        function checkall(){
            var hobby = document.getElementsByTagName("input");
           
            for(var i = 0; i < hobby.length; i ++){
                if(hobby[i].getAttribute("type") == "checkbox"){
                    hobby[i].checked = true;
                }
            }
           
        }
        function clearall(){
            var hobby = document.getElementsByName("hobby");
            
            for(var i = 0; i < hobby.length; i ++){
                hobby[i].checked = false;
            }   
            
        }
        
        function checkone(){
            var j=document.getElementById("wb").value;
            
            if(1 <= j <= 6){
                var hobby = document.getElementById("hobby" + parseInt(j));
                hobby.checked = true;                
            }         
        }       
        </script>
    </body>
</html>
-->

<!-- ********************************************************************************* -->

<!-- DOM节点相关 -->
<!--
一. nodeName:节点的名称; 2. nodeValue:节点的值; 3. nodeType:节点的类型
二. nodeValue 属性：节点的值
    1. 元素节点的 nodeValue 是 undefined 或 null
    2. 文本节点的 nodeValue 是文本自身
    3. 属性节点的 nodeValue 是属性的值(注意什么是属性节点)
三. eg：<p title="example">This is an example!</p>中，p为元素节点，下面有两个节点，属性节点title="example"和文本节点This is an example!
四. 取childNodes时需要注意：节点之间的空白符，在firefox、chrome、opera、safari浏览器是文本节点；ie则忽略空白符。空白符是从父元素的标签紧贴着出现的，无论空白多长，都标记为一个空白符。
五. parentNode,父节点只能有一个
六. appendChild():在指定节点的最后一个子节点列表之后添加一个新的子节点。//appendChild(newnode);
    insertBefore():insertBefore() 方法可在已有的子节点前插入一个新的子节点。//insertBefore(newnode,node);
    removeChild():removeChild() 方法从子节点列表中删除某个节点。如删除成功，此方法可返回被删除的节点，如失败，则返回 NULL。如要彻底删除，则需要将返回值赋为null，不然节点还存在于返回值中。//nodeObject.removeChild(node);
    //如果要删除自己，则执行node.parentNode.removeChild(node);
    replaceChild():replaceChild 实现子节点(对象)的替换。返回被替换对象的引用。 //node.replaceChild (newnode,oldnew ) 
七. 增加节点：
    createElement()/createTextNode()
-->
<!--
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Document</title>
  </head>
  <body>
    <div id="demo">
      <div id="thisNode">点击删除我</div>
    </div>
    <script type="text/javascript">
      document.getElementById("thisNode").onclick=function(){
      this.parentNode.removeChild(this);
    }
    </script>
  </body>
</html>
-->
<!--
<!DOCTYPE HTML>
<html>
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>无标题文档</title>
  </head>

  <body>
  <div id="content">
    <h1>html</h1>
    <h1>php</h1>
    <h1>javascript</h1>
    <h1>jquery</h1>
    <h1>java</h1>
  </div>

  <script type="text/javascript">
  function clearText() {
    var content=document.getElementById("content");
    var num = content.childNodes.length;
    for(i = num - 1; i >= 0; i --){
        content.removeChild(content.childNodes[i]);
    }  //注意此处用倒序而不是正序，因为每次删除后，childNodes的序列号会改变。
  }
  </script>

  <button onclick="clearText()">清除节点内容</button>

  </body>
</html>
-->

<!-- ********************************************************************************* -->

<!--
  【"conclick"相关】
1、事件处理函数：
  <a href="http://www.example.com" onclick="del();return flase;">可以保证在点击时调用del()函数，而不引发默认的"http://www.example.com"网址的跳转[该方案可以平稳退化]。<a href="javascript:;" onclick="del()">利用伪协议"javascript:"也可以达到类似效果，但是存在问题是在较老浏览器中会去尝试打开那个链接而失败，同时支持伪协议但禁用javascript功能的浏览器会什么也不做[该方案不可以平稳退化]。
2、上面例子中的onclick，里面的函数del()可以为del(this);表示传入事件对象；也可以为del("A","B");表示传入参数A和B。
-->

<!-- 【尤其注意】table的子元素是text空节点和tbody节点，而tr和td都在tbody节点中，所以需要获取table的最后一个子节点元素才行。注意下面例子的del(obj)函数。 -->

<!--
<!DOCTYPE html>
<html>
 <head>
  <title> new document </title>  
  <meta charset="UTF-8"> 
  <script type="text/javascript"> 
  
      window.onload = function(){
                  
     // 鼠标移动改变背景,可以通过给每行绑定鼠标移上事件和鼠标移除事件来改变所在行背景色。
        var Tr= document.getElementsByTagName("tr");
        for(i = 0; i < Tr.length; i ++){
          Tr[i].onmouseover = function(){
            this.style.backgroundColor = "#f2f2f2";  //！！注意此处应该为this而不是Tr[i]
          }
          Tr[i].onmouseout = function(){
            this.style.backgroundColor = "#fff";
          }
        }
    
      /*var tr=document.getElementsByTagName("tr");
        for(var i= 0;i<tr.length;i++){
              bgcChange(tr[i]);
        }
        
        function bgcChange(obj){
          obj.onmouseover=function(){
            obj.style.backgroundColor="#f2f2f2";
          }
          obj.onmouseout=function(){
            obj.style.backgroundColor="#fff";
          }
        }*/
   
   }
     
      // 编写一个函数，供添加按钮调用，动态在表格的最后一行添加子节点；
      function add(){
          var aTable = document.getElementById("table").lastChild;
          var nTh = document.createElement("th");
          var nTr = document.createElement("tr");
          for(var i = 0; i < 3; i ++){
              if(i == 2){
                nTh.innerHTML = "<a href=\"javascript:;\" onclick=\"del(this)\">删除</a>";
              }            
              nTr.appendChild(nTh);
              nTh = document.createElement("th");

          }
          aTable.appendChild(nTr);
      }
        
     
     // 创建删除函数
     function del(obj){
          var aTable = document.getElementById("table").lastChild;  //!!特别注意此处！！使用了.lastChild才是真正取到了table元素（即包含有tr和th的tbody节点）。
          var aTr = obj.parentNode.parentNode;
          aTable.removeChild(aTr);
     }


  </script> 
 </head> 
 <body> 
     <table border="1" width="50%" id="table">
     <tr>
    <th>学号</th>
    <th>姓名</th>
    <th>操作</th>
     </tr>  

     <tr>
    <td>xh001</td>
    <td>王小明</td>
    <td><a href="javascript:;" onclick="del(this)">删除</a></td>  
     </tr>

     <tr>
    <td>xh002</td>
    <td>刘小芳</td>
    <td><a href="javascript:;" onclick="del(this)">删除</a></td>  
     </tr>  

     </table>
     <input type="button" value="添加一行" onclick="add()" />   
 </body>
</html>
-->

<!-- ********************************************************************************* -->

1、静态作用域(又称词法作用域)：由程序定义的位置决定，与代码执行顺序无关。在编译阶段就决定了变量的引用。
   动态作用域：由程序运行时刻决定，与代码执行顺序有关。以栈的形式储存变量，读取时也按栈的顺序读取，即取离栈顶最近的值。
2、JS变量作用域：JS使用静态作用域，JS没有块级作用域(全局作用域、函数作用域)，ES5中使用词法环境管理静态作用域
3、函数声明和函数表达式：函数声明的函数对象是提前创建的，函数表达式的函数对象是执行到这一条语句的时候才创建的。即这两个都会创建一个内部的函数对象，只是创建的时间不同而已。
eg: function f(){
      alert(foo);
    }   //函数声明
    (function(){
      alert(foo);
    })();  //匿名函数表达式
    (function A(){
      A=1;
      alert(A);  //此处的A是不能被改写的，故虽然前面被改写为1，但是实际上其值还是为函数A
    })();  //带名称的函数表达式    
    f();  
4、闭包:作用为保存现场&封装
4.1保存现场
        function addHandlers(nodes){
          for(var i = 0; i < nodes.length; i ++){
            nodes[i].onclick = function() {
              alert(i);
            }
          }
        }

  解释：匿名函数的外层作用域(outer)为addHandlers的环境;addHandlers的环境里有形参nodes同时定义了一个i,初始化时为undefined,当循环开始时，第一次i会被赋值为0;addHandlers的outer为全局环境(global Environment);虽然循环里每调用一次nodes[i].onclick都会创建一个匿名函数，但可以发现这些匿名函数的外层环境都是一样的，由于外层环境只和定义时有关系，故其outer都是addHandlers的环境(从第一句可以发现);当这个匿名函数开始执行的时候，其找的都是addHandlers这个环境里的i;在这个循环里，如果只是事先定义的话，这些匿名函数并不会执行，只有在点击函数的之后其才会执行，也就是说，在注册事件时这些函数是不会执行的;当事件注册完，即循环执行完后，addHandlers里面的i等于nodes.length;当我们在页面上去点击某一行时，其就会执行匿名函数，在执行匿名函数之前，就会沿着匿名函数的作用域链去找，它就会找到addHandlers里面的i，此时这个i值已经变为了nodes.length。所以，一旦写成这种方式，无论你在什么时候也无论循环执行了多少次，最后当事件处理函数(本例中为这个执行弹出i操作的匿名函数)开始执行的时候，其弹出i都是一样的，因为它都是指向了addHandlers里面的i，故无论移到哪一个nodes，其弹出的i都是同一个值为nodes.length。
        function addHandlers(nodes){
          function helper(i) {
            return funcyion() {
              alert(i);
            } 
          }
          for(var i = 0; i < nodes.length; i ++){
            nodes[i].onclick = helper(i);
          }
        }
  解释：匿名函数的outer为helper的环境，helper的outer为addHandlers的环境;helper函数的执行结果为一个匿名函数，这个匿名函数就是一个闭包，因为这个匿名函数引用了外部词法环境中helper的形参i，所以每调用一次helper函数，这个helper函数都会返回一个闭包，i的值就被这个闭包保存起来了;所以在这个例子里，最后这个匿名函数执行的时候引用的i不是addHandlers里定义的i，而是helper的词法环境里定义的i；在循环体里，helper函数会执行很多次，即每调用一次循环就会执行一次helper，每次调用helper时其都会独立创建一个环境，因为每次helper执行前都会独立创建一个环境，这些环境中的i彼此之间是独立的，是不会彼此有影响的(比如helper(0)和helper(1)是有各自有各自环境的)。故每执行一次循环，就创建一个闭包，而这个闭包里就会保存传入的i值。当点击页面上某一行时，实际上就弹出其当时保存在闭包里的i的值。
4.2模块封装
    var observer = (function() {
      var observerList = [];
      return {
        add: function(obj) {
          observerList.push(obj);
        },
        empty: function() {
          observerList = [];
        },
        getCount: function() {
          return observerList.length;
        },
        get: function() {
          return observerList;
        }
      }
    })();
  解释：由于闭包是一个函数作用域，其很好地实现了信息隐藏的作用。外部变量是不能访问到内部的变量，而内部变量可以访问到外部的变量。使用闭包实现封装，可以让封装出来的对象只暴露接口，而其内部可以共享自由变量，也就是说他可以把有一些变量不暴露给外部变量，即把私有变量放到闭包里作为自由变量，然后返回一个对象，这个对象只对外部暴露接口